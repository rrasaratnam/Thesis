% !TEX root = ../main.tex
%\chapter{Background}
\chapter{Grundlagen}
\label{sect:basics}

Dieses Kapitel führt in die für das Framework relevanten Konzepte und Technologien ein. Zunächst wird der Begriff der E/E-Architektur samt ihrer Evolution und ihres Aufbaus erläutert. Anschließend wird die Softwarearchitektur behandelt: Nach der Definition grundlegender Begriffe werden die Prinzipien der Serviceorientierten Architektur vorgestellt und darauf aufbauend die Rolle von Middleware in der Fahrzeugtechnik beleuchtet. Ein weiterer Abschnitt erläutert die Motivation, Ziele und Methoden zur Validierung von Architekturen. Den Abschluss bildet die Vorstellung des für die Implementierung verwendeten Webentwicklungs-Stacks.
\section{Automobile E/E-Architektur}
\label{sect:eearchitecture}

Für alle softwaregesteuerten Funktionen innerhalb eines Fahrzeuges bildet die \gls{eea} das physikalische und logische Fundament. Sie definiert die grundlegende Organisation von Hardwarekomponenten wie \gls{ecu}, Sensoren, Energieversorgungssystemen und Kabelbäumen und steuert deren Kommunikation und Interaktion, um die erwarteten Funktionen zu realisieren \cite{jiang2019vehicle}. Diese Architektur hat im Laufe der Zeit mehrere Varianten durchlaufen und wird stetig weiterentwickelt. Im Folgenden werden die evolutionären Stufen der \gls{eea} genauer betrachtet.

\subsection{Evolution der Architekturentwicklung}

Ursprünglich waren Fahrzeuge hauptsächlich mechanische Produkte, was sich jedoch mit der Einführung von Elektronik, wie Motorsteuergeräte und Airbags, änderte und die Ära der Elektrifizierung innerhalb der Automobilindustrie begann. Zunächst waren, aufgrund der geringen Anzahl, die Verbindungen zwischen den elektronischen Komponenten meist Punkt-zu-Punkt, sprich Komponenten wurden direkt miteinander verbunden. Dies führte jedoch durch die steigende Anzahl an \glspl{ecu}, zu einem Anstieg der Komplexität und des Kabelbaums. Um die Kommunikationseffizienz zu verbessern und die Komplexität zu reduzieren, wurden \gls{can}-Busse eingeführt. In der Folge wurde auch an Technologien wie \gls{lin} und FlexRay entwickelt und eingesetzt, um die verschiedenen Kommunikationsanforderungen zu erfüllen, sodass Komponenten innerhalb einer Domäne Informationen gemeinsam nutzen.

Das Konzept der Funktionsdomäne rückte, aufgrund der wachsenden Komplexität und Funktionen immer stärker in den Vordergrund. \glspl{ecu} und Funktionen wurden in Domänen wie Fahrwerk, Karosserie und Infotainment unterteilt. Durch die Nachfrage nach domänenübergreifender Kommunikation wurde die Gateway-Funktion, welche zuvor von einzelnen \glspl{ecu} übernommen wurde, zunehmend in einem dedizierten, zentralen Gateway gebündelt.
Obwohl dieser Ansatz die Mainstream-Lösung war, führte die Zunahme der Funktionen und Rechenanforderungen zu einer starken Zunahme der ECUs. Dies hatte komplexe Kabelbäume mit erhöhtem Gewicht und Kosten zur Folge, außerdem konnte der Ausfall durch das ausfallen des zentralen Gateways zu einem Zusammenbruch des gesamten Netzwerks führen.

Um diesem Problem entgegenzuwirken, wurden \glspl{dcu} eingeführt, welche Funktionen einiger \glspl{ecu} innerhalb einer jeweiligen Funktionsdomäne integrieren und somit die Anzahl der \glspl{ecu} und die Belastung der Gateways reduzieren. Um die bestmögliche Kommunikation zu garantieren, werden \glspl{dcu} über das Automotive Ethernet mit dem zentralen Gateway verbunden, welches eine höhere Bandbreite bietet.

Ein weiterer Ansatz, der neben der domänenbasierten Architektur existiert, ist die zonenbasierte Architektur. Um Komplexität und das Gewicht der Verkabelung zu reduzieren, werden Komponenten anstatt nach Funktionen, basierend auf ihrer physischen Position innerhalb des Fahrzeuges unterteilt. Anstatt wie bei \glspl{dcu} die Funktionen einer Domäne zu übernehmen, übernehmen \glspl{zsu} die Funktionen, die in den entsprechenden physischen Zonen stattfinden. Auch hier wird die Kommunikation über das Automotive Ethernet durchgeführt. Dieser Ansatz reduziert die Anzahl der \glspl{ecu} und Kabelaufwand (Anzahl, Länge, Gewicht) und verringert so die Komplexität der E/E-Architektur deutlich

Erst die Evolution der \gls{eea} ermöglicht moderne Softwarekonzepte. Das folgende Unterkapitel beschreibt daher die Softwarearchitekturen, die diese neue Hardware-Basis nutzt.
%TODO: (Future Trends?)

\section{Softwarearchitekturen in Fahrzeugen}
\label{sect:sa}
Die allgemeine Definition einer Softwarearchitektur ist nach Bass et al. \cite{bass2021} eine systematische Gliederung eines Softwaresystems in einzelne Bausteine, die Festlegung ihrer Schnittstelle sowie die Prinzipien, nach denen diese Komponenten zusammenwirken und organisiert sind. Seitdem sich der Schwerpunkt von Fahrzeugen weg von mechanikzentrierten Systemen bewegt hat und hin zu intelligenten, softwaredefinierten Plattformen, gibt es innerhalb der Automobilindustrie einen großen Fortschritt bezüglich der Softwarefunktionalität. Um bei diesem Fortschritt den Überblick zu behalten, ist eine fundierte Softwarearchitektur unerlässlich.

Zu Beginn setzte man auf klassische, geschichtete Architekturen wie OSEK/VDX und AUTOSAR Classic, jedoch merkte man mit dem Aufkommen des Konzepts eines \gls{sdv} sowie der steigenden Software-Komplexität, dass die klassische Softwarearchitektur an ihre Grenzen stieß. Es gibt einige Gründe, wie die starre, monolithische Schichtenstruktur: Funktionen sind fest an Schichten gebunden, was Anpassungen einzelner Komponenten oder den Austausch von Modulen kaum umsetzbar machte.

In diesem Unterkapitel wird ein Einblick in die \glspl{soa} gegeben, die beschriebenen Schwächen der klassischen Softwarearchitektur überwinden. Anschließend wird die Middleware erläutert, die als technische Vermittlungsschicht dient.

\subsection{Serviceorientierte Architektur}
\label{subsect:soa}
Die Notwendigkeit, Softwaremodule dynamisch bereitzustellen erfordert einen flexiblen Ansatz. Hier setzt die \gls{soa}, welche bereits in der Webentwicklung fester Bestandteil ist, an. Nach Rumez et al.\cite{rumezOverviewAutomotiveServiceOriented2020} ein Architekturmuster, bei dem Anwendung als lose gekoppelte, wiederverwendbare Dienste organisiert werden. Jeder Dienst bietet eine klar definierte Funktionalität über gut beschriebene Schnittstellen und kann zur Laufzeit von beliebigen Clients zugegriffen werden.

Im Gegensatz zum klassischen signalorientierten Ansatz, bei dem die Konfiguration der Kommunikationspfade vollständig statisch zur Design-Zeit erfolgt, setzt der \gls{soa}-Ansatz auf eine dynamische Konfiguration während der Laufzeit. Durch das dynamische Aufrufen von Diensten zur Laufzeit erhält die Architektur mehr Flexibilität. So lassen sich Funktionen einfacher hinzufügen, entfernen oder bearbeiten, ohne dass eine komplette Neuzuweisung der Software erforderlich ist. Dank der Middleware-Schicht, auf die im nächsten Abschnitt näher eingegangen wird, sind die verschiedenen Anwendungen unabhängig von dem Steuergerät, auf dem ein Dienst läuft, sowie vom zugrunde liegenden Netzwerk aufgebaut. Diese Entkoppelung von der Plattform ermöglicht es der Software, wiederverwendbar und portierbar zu sein. Ein weiteres Merkmal des \gls{soa}-Ansatzes sind Kommunikationsmuster, die Daten nur bei Bedarf übertragen. Im Gegensatz dazu verschickt die klassische Softwarearchitektur in zyklischen Abständen Daten – selbst wenn kein Empfänger vorhanden ist. Dadurch kann die entstehende Netzwerklast auf das Nötigste reduziert werden, was die Effizienz  steigert. Darüber hinaus kapselt jeder Dienst hinter einer Schnittstelle eine klar definierte Funktionalität. So lassen sich diese Dienste in unterschiedliche Kontexte und Projekten wiederverwenden, wodurch der Entwicklungs- und Testaufwand gesenkt wird. Ein weiterer Vorteil ist die Integration externer und On-Demand-Dienste: \gls{soa} unterstützen die dynamische Anbindung von Backend- und Cloud-Diensten, welche weitgehend transparent ist. Außerdem lassen sich \gls{soa} an wachsenden Anforderungen anpassen ohne dass das Gesamte System neu zu strukturieren. Aus den genannten Gründen erweißt sich die \gls{soa} als flexiblere und anpassungsfähiger als die klassische Variante der Softwarearchitektur.

Um die Vorteile der \gls{soa} realisieren zu können benötigt es eine Zwischenschicht zwischen Anwendung und Netz. Im folgenden Abschnitt wird die Middleware-Schicht untersucht, welche die \gls{soa}-Prinzipen technisch umsetzt. Dabei wird zunächst auf Aufbau und Funktionen eingegangen. Anschließend wird die ASOA-Middleware genauer untersucht.

\subsection{Automobile Middleware}
\label{subsect:middle}
Innerhalb moderner, verteilter Softwaresysteme ist die Middleware-Schicht eine wichtige Vermittlungsebene. Neely et al. \cite{neely2006adaptive} definieren die Middleware als Schicht zwischen Anwendungssoftware und Systemsoftware. In Systemen mit Netzwerkanbindung vermittelt sie zusätzlich zwischen Anwendungssoftware, Betriebssystem und Netzwerkkommunikationsschichten. Dabei liegt ihre Hauptaufgabe darin, die Komplexität des zugrunde liegenden Systems zu abstrahieren \cite{neely2006adaptive}. Im Bereich der Fahrzeugtechnik wird die Middleware noch einmal in zwei Sub-Schichten unterteilt \cite{kluner2024moderna}:
\begin{itemize}
  \item Kommunikations-Middlewares (untere Schicht), die den Datenaustausch zwischen ECUs organisieren und \gls{qos}-Funktionen bereitstellen.
  \item Architekturplattformen (obere Schicht), die umfassende Frameworks für die Entwicklung und Bereitstellung automobiler Softwaresysteme liefern.
\end{itemize}
Nun wird untersucht, wie die Kommunikations-Middlewares und Architekturplattformen konkret arbeiten.

Als untere Sub-Schicht sorgt die Kommunikations-Middleware dafür, dass sämtliche Details des Datenaustauschs im \gls{ivn} abstrahiert und Anwendungen von der zugrunde liegenden Netzwerktopologie entkoppelt sind. Sie sorgt zudem dafür, dass strukturierte Daten wie z.B. Sensormesswerte automatisch seralisiert und über Ethernet, CAN-Gateway oder Shared-Memory-Kanäle verteilt werden. Dies wird durchgeführt, ohne dass Entwickler sich mit den Kommunikationsprotokollen befassen müssen. Außerdem ermöglicht sie die Definition und Einhaltung von \gls{qos}-Parametern. Des Weiteren sorgt ein intelligentes Routing- und Topologie-Management auf der Netzwerk-Ebene dafür, dass Nachrichten den bestmöglichen Pfad für die Übertragung wählen, während ein Real-Time-Scheduler die Übertragungen koordiniert.

Mit der Kommunikations-Middleware als Basis, löst die Architekturplattform Herausforderungen in Bezug auf die Entwicklung von Automobil-Softwaresystemen. Sie stellt eine umfassende Laufzeitumgebung bereit und bietet Entwicklern standardisierte Dienste und APIs. Das Ziel ist es die bestehende Komplexität weiter zu verringern, sodass Entwickler den Fokus auf die Anwendungslogik setzen können, anstatt sich mit systemnahen Aufgaben zu beschäftigen. Abgesehen von der Kommunikation, gehört zunächst das umsetzen der Software-Designmustern, wie das zuvor angesprochene \gls{soa}-Prinzip, zu den Kernaufgaben. Ebenso Ressourcenmanagement und Orchestrierung , bei der die Ressourcen von inaktiven Diensten freigegeben werden. Das Ziel hierbei ist eine situationsabhängige optimale Ressourcenzuweisung. Als nächstes ist die deterministische Ausführung sowie die Unterstützung bei der Einhaltung von Echtzeitanforderung zu nennen, um Verzögerungen im Softwaresystem zu vermeiden. Des Weiteren bietet sie oft Funktionen zur Cybersicherheit, wie Authentifizierung, Zugriffskontrolle, Verschlüsserung etc. an um Schwachstellen innerhalb des \glspl{ivn} zu reduzieren. Darüber hinaus sorgt die obere Schicht dafür, dass Over-the-Air-Updates, Installation/Deinstallation von Software-Paketen, sowie die Konfiguration von Anwendungen während der laufzeit durchgeführt werden und bietet dementsprechend Funktionen an. Eine weitere wichtige Aufgabe ist die Verwaltung des Systemzustands und die Überwachung des Lebenszyklus von Softwarekomponenten. Nicht zuletzt bietet die Architekturplattform Entwicklungswerkzeuge an, welche für die Entwicklung und Bereitstellung verwendet werden.

\section{Validierung von Architekturen}
\label{sect:validerung}

Wie bereits zu Beginn der Arbeit dargelegt, ist die frühzeitige Prüfung von Architekturen von entscheidender Bedeutung. Das technische Ziel der Architekturvalidierung ist daher, die Korrektheit und Konsistenz eines Systementwurfs anhand definierter Qualitätsmethoden, wie  ISO 26262 für funktionale Sicherheit oder ISO 25010 was sind die Zielefür Softwarequalität, zu bewerten, noch bevor die Implementierung beginnt \cite{venkitachalam2015}. Dieses Ziel lässt sich in die folgenden Teilziele unterteilen: Früherkennung von Fehlern, Kostenreduzierung, Sicherstellung von Qualität und Standardkonformität, Verifikation des Systemverhaltens und der Anforderungen, Beherrschung der Systemkomplexität und Verbesserung des Verständnisses\cite{venkitachalam2015} \cite{kang2019formal} \cite{bucher2019crosslayera}.
Im folgenden werden die unterschiedlichen Ansätze zum validieren der Architekturen genauer betrachtet.
\subsection{Validierungsverfahren}

Es existieren veschiedene Ansätze zur Validierung eingesetzt, um die Gültigkeit von automobilen Systemen zu gewährleisten. Diese lassen sich in folgende Kategorien unterteilen\cite{kollmann2010comparative} \cite{venkitachalam2015} \cite{weissnegger2016automatic}:


\section{Webentwicklungs-Stack}